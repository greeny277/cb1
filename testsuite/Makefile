# -*- tab-width: 8 -*-
# Externally configurable variables:
# The path to the compiler
COMPILER ?= ../bin/mcc
# Options used by the compiler
COMPILEROPTS ?=	 
# Script to run the binaries
RUNBIN ?= ../bin/runbinary
# timeout for binaries
TIMEOUT ?= 5
export TIMEOUT
############ if you need to edit the rest, please tell me. #######################

############ global constants ######################################
# suffixes of temporary files created by compilation
TMPSUF := o S AST CIL ces.tmp

# suffixes of temporary files created by running the testcases
TCTMPSUF := res.tmp out.tmp 

# (sub-)directories containing .e files 
ALLSUBDIRS := . correct correct_uses_real incorrect_grammar incorrect_vardecl incorrect_type

# subdirs for exercise 1
SUBDIRS_EX1 := . correct correct_uses_real incorrect_grammar

# subdirs for exercise 2
SUBDIRS_EX2 := . correct correct_uses_real incorrect_grammar incorrect_vardecl

# subdirs for exercise 3
SUBDIRS_EX3 := . correct correct_uses_real incorrect_grammar incorrect_vardecl incorrect_type

# subdirs for last exercise, when we want to compile and run
SUBDIRS_RUN := . correct incorrect_grammar incorrect_vardecl incorrect_type

############ make file functions ##################################
# given a list of directories, returns a list of all .e files in these directories
F_SOURCES = $(foreach dir,$(1),$(wildcard $(dir)/*.e))

# Programs generated by this makefile end with .e.run.
# given a list of .e - files, returns a list of corresponding .e.run - files
F_BINS = $(patsubst %.e,%.e.run,$(1))

# Every testcase has a .X.out - file, where X is 1, 2, 3, ...
# This function finds the testcases for a source file
F_TESTCASES = $(patsubst %.out,%,$(foreach src,$(1),$(wildcard $(src).?.out)))

# this function generates a list of temporary files
# for a source file and its testcases
F_TEMPFILES = $(foreach suff,$(TMPSUF), $(patsubst %.e,%.e.$(suff),$(1))) \
	      $(foreach suff,$(TCTMPSUF), $(patsubst %,%.$(suff),$(call F_TESTCASES, $(1))))

# after successfull compilation of a source file, we generate a compilation stamp file, which will be empty.
# this function gives us a list of all compilation stamp files.
F_COMPSTAMPS = $(patsubst %.e,%.e.compstamp, $(1))

# same thing after running a testcase.
F_RUNSTAMPS = $(patsubst %.e,%.e.runstamp, $(1))

############ make weirdness with implicit rules ###########################
# there are some funny rules deleting .e files, disable them!
.SUFFIXES:


########### rules for generating files from other files ###################

# given an .e file, compile it, check whether compilation was successfull and create a .compstamp-file
%.e.compstamp: %.e
	@if [ "$$(cat $<.ces)" = "0" ] ; then				\
		/bin/echo -ne "compiling $<:\texpecting SUCCESS: ";	\
	else								\
		/bin/echo -ne "compiling $<:\texpecting FAIL:    ";	\
	fi
	@$(COMPILER) $(COMPILEROPTS) -o $<.run $< > /dev/null 2> /dev/null; echo $$? > $<.ces.tmp
	@if [ "$$(cat $<.ces.tmp)" = "0" ] ; then	\
		echo SUCCESS;				\
	else						\
		echo FAIL;				\
	fi
	@diff -q $<.ces $<.ces.tmp > /dev/null 2> /dev/null ||	exit 1
	@touch $@

# run all testcases, and if they're successfull, touch a stampfile
%.e.runstamp: %.e.compstamp
	@for out in $(patsubst %.e.compstamp,%.e.,$<)*.out; do		\
		bin=$(patsubst %.e.compstamp,%.e.run,$<);		\
		[ -f $$out ] || continue;				\
		[ -f $$bin ] || continue;				\
		in=$${out%.out}.in ;					\
		res=$${out%.out}.res ;					\
		if [ -f "$$in" ] ; then					\
			echo "./$$bin > $$out.tmp < $$in";		\
			$(RUNBIN) ./$$bin $$in > $$out.tmp < $$in;	\
			echo $$? > $$res.tmp;				\
		else							\
			echo "./$$bin > $$out.tmp" ;			\
			$(RUNBIN) ./$$bin > $$out.tmp ;			\
			echo $$? > $$res.tmp;				\
		fi;							\
		diff --strip-trailing-cr -u $$res $$res.tmp || exit 1 ;	\
		diff --strip-trailing-cr -u $$out $$out.tmp || exit 1 ;	\
	done
	@touch $@

########### and now, finally: our targets ###############################
all: compile run

# compiling by default depends on creating .e.compstamp - files.
# creating these files will (as side effect) compile our E-Files :-)
compile: $(call F_COMPSTAMPS, $(call F_SOURCES,$(SUBDIRS_RUN)))

# analogously: we have a rule that creates .e.runstamp - files,
# and, as a side effect, runs the test cases.
# so we depend on creating all the .e.runstamp - files, which will
# run the testcases
run: $(call F_RUNSTAMPS, $(call F_SOURCES,$(SUBDIRS_RUN)))

# special targets. Up to Exercise 3, we can not yet correctly detect
# all errors, so we do not compile everything yet.
uebung01: $(call F_COMPSTAMPS, $(call F_SOURCES, $(SUBDIRS_EX1)))
uebung02: $(call F_COMPSTAMPS, $(call F_SOURCES, $(SUBDIRS_EX2)))
uebung03: $(call F_COMPSTAMPS, $(call F_SOURCES, $(SUBDIRS_EX3)))

clean:
	@echo removing stamp files
	@rm -f $(call F_COMPSTAMPS, $(call F_SOURCES,$(ALLSUBDIRS)))
	@rm -f $(call F_RUNSTAMPS,  $(call F_SOURCES,$(ALLSUBDIRS)))
	@echo removing binaries and temp files
	@rm -f $(call F_BINS, $(call F_SOURCES, $(ALLSUBDIRS)))
	@rm -f $(call F_TEMPFILES, $(call F_SOURCES, $(ALLSUBDIRS)))
	rm -f */*.tmp */*.o */*.S *.tmp *.o *.S 
	rm -f */*.dot */*.dump */*.cil *.dot *.dump *.cil
	rm -f */*.AST */*.CIL *.AST *.CIL

help:
	@echo Verfügbare Targets:
	@echo "   all      - default target, ruft 'compile' und 'run' auf"
	@echo "   compile  - kompiliert alle Programme (bis auf die, die Gleitkommazahlen verwenden)"
	@echo "   run      - testet die Programme, für die Testcases existieren"
	@echo "   clean    - räumt temporäre Dateien und Kompilatsergebnisse auf"
	@echo "   uebung01 - kompiliert alle Programme die nach Übung 1 kompilieren sollen"
	@echo "   uebung02 - kompiliert alle Programme die nach Übung 2 kompilieren sollen"
	@echo "   uebung03 - kompiliert alle Programme die nach Übung 3 kompilieren sollen"
	@echo "   help     - dieses Target"
	@echo "Zu Risiken und Nebenwirkungen lesen sie das README und fragen sie ihren "
	@echo "Übungsleiter oder Professor."


.PHONY: all clean compile run uebung01 uebung02 uebung03 help
