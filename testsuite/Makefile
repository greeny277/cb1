# -*- tab-width: 8 -*-
# Externally configurable variables:
# The path to the compiler
MCC ?= ../bin/mcc
# Options used by the compiler
MCCFLAGS ?=  
# Script to run the binaries
RUNBIN ?= ../bin/runbinary
# timeout for binaries
TIMEOUT ?= 15
export TIMEOUT
############ if you need to edit the rest, please tell me. #######################

############ global constants ######################################
# suffixes of temporary files created by compilation
TMPSUF := o S AST CIL ces.tmp loops *.imdoms *.cfg cil.json *.predictableExpressions *.availableExpressions *.LiveVars *.postdump *.domBounds *.AvailableExpressions *.InterferenceGraph *.cil.json

# suffixes of temporary files created by running the testcases
TCTMPSUF := res.tmp out.tmp 

# (sub-)directories containing .e files 
ALLSUBDIRS := . correct correct_uses_real incorrect_grammar incorrect_vardecl incorrect_type

# subdirs for exercise 1
SUBDIRS_EX1 := . correct correct_uses_real incorrect_grammar

# subdirs for exercise 2
SUBDIRS_EX2 := . correct correct_uses_real incorrect_grammar incorrect_vardecl

# subdirs for exercise 3
SUBDIRS_EX3 := . correct correct_uses_real incorrect_grammar incorrect_vardecl incorrect_type

# subdirs for last two exercises, when we want to compile and run
SUBDIRS_RUNNABLE := . correct
SUBDIRS_COMPILALE := . correct  incorrect_grammar incorrect_vardecl incorrect_type

############ make file functions ##################################
# given a list of directories, returns a list of all .e files in these directories
F_SOURCES = $(foreach dir,$(1),$(wildcard $(dir)/*.e))

# Programs generated by this makefile end with .e.run.
# given a list of .e - files, returns a list of corresponding .e.run - files
F_BINS = $(patsubst %.e,%.e.run,$(1))

# Every testcase has a .X.out - file, where X is 1, 2, 3, ...
# This function finds the testcases for a source file
F_TESTCASES = $(patsubst %.out,%,$(foreach src,$(1),$(wildcard $(src).?.out)))

# this function generates a list of temporary files
# for a source file and its testcases
F_TEMPFILES = $(foreach suff,$(TMPSUF), $(patsubst %.e,%.e.$(suff),$(1))) \
	      $(foreach suff,$(TCTMPSUF), $(patsubst %,%.$(suff),$(call F_TESTCASES, $(1))))

# after successfull compilation of a source file, we generate a compilation stamp file, which will be empty.
# this function gives us a list of all compilation stamp files.
F_COMPSTAMPS = $(patsubst %.e,%.e.compstamp, $(1))

# same thing after running a testcase.
F_RUNSTAMPS = $(patsubst %.e,%.e.runstamp, $(1))

# same thing after running a testcase.
F_INTERPSTAMPS = $(patsubst %.e,%.e.interpstamp, $(1))
F_INTERPFILES  = $(patsubst %.e,%.e.json, $(1))

############ make weirdness with implicit rules ###########################
# there are some funny rules deleting .e files, disable them!
.SUFFIXES:


########### rules for generating files from other files ###################

# given an .e file, compile it, check whether compilation was successfull and create a .compstamp-file
%.e.compstamp: %.e
	@if [ "$$(cat $<.ces)" = "0" ] ; then				\
		/bin/echo -ne "compiling $<:\texpecting SUCCESS: ";	\
	else								\
		/bin/echo -ne "compiling $<:\texpecting FAIL:    ";	\
	fi
	@$(MCC) $(MCCFLAGS) -o $<.run $< > /dev/null 2> /dev/null; echo $$? > $<.ces.tmp
	@if [ "$$(cat $<.ces.tmp)" = "0" ] ; then	\
		echo SUCCESS;				\
	else						\
		echo FAIL;				\
	fi
	@diff -q $<.ces $<.ces.tmp > /dev/null 2> /dev/null ||	exit 1
	@touch $@

%.e.json: %.e
	$(MCC) $(MCCFLAGS) --dump-cil-to-file-and-exit $@ $<

# run all testcases, and if they're successfull, touch a stampfile
%.e.runstamp: %.e.run %.e.compstamp
	@for out in $(patsubst %.e.run,%.e.,$<)*.out; do			\
		[ -f $$out ] || continue;				\
		in=$${out%.out}.in ;					\
		res=$${out%.out}.res ;					\
		if [ -f "$$in" ] ; then					\
			echo "./$< > $$out.tmp < $$in";			\
			$(RUNBIN) ./$< $$in > $$out.tmp < $$in;		\
			echo $$? > $$res.tmp;				\
		else							\
			echo "./$< > $$out.tmp" ;			\
			$(RUNBIN) ./$< > $$out.tmp ;			\
			echo $$? > $$res.tmp;				\
		fi;							\
		diff --strip-trailing-cr -u $$res $$res.tmp || exit 1 ;	\
		diff --strip-trailing-cr -u $$out $$out.tmp || exit 1 ;	\
	done
	@touch $@

# interpret all testcases, and if they're successfull, touch a stampfile
%.e.interpstamp: %.e.json
	@export INTERPRET=True;						\
	for out in $(patsubst %.e.json,%.e.,$<)*.out; do		\
		[ -f $$out ] || continue;				\
		in=$${out%.out}.in ;					\
		res=$${out%.out}.res ;					\
		if [ -f "$$in" ] ; then					\
			echo "interpret ./$< > $$out.tmp < $$in";	\
			$(RUNBIN) ./$< $$in > $$out.tmp < $$in;		\
			echo $$? > $$res.tmp;				\
		else							\
			echo "interpret ./$< > $$out.tmp" ;		\
			$(RUNBIN) ./$< > $$out.tmp ;			\
			echo $$? > $$res.tmp;				\
		fi;							\
		diff --strip-trailing-cr -u $$res $$res.tmp || exit 1 ;	\
		diff --strip-trailing-cr -u $$out $$out.tmp || exit 1 ;	\
	done
	@touch $@

########### and now, finally: our targets ###############################
all: compile run

# compiling by default depends on creating .e.compstamp - files.
# creating these files will (as side effect) compile our E-Files :-)
compile: $(call F_COMPSTAMPS, $(call F_SOURCES,$(SUBDIRS_COMPILALE)))

# analogously: we have a rule that creates .e.runstamp - files,
# and, as a side effect, runs the test cases.
# so we depend on creating all the .e.runstamp - files, which will
# run the testcases
run: $(call F_RUNSTAMPS, $(call F_SOURCES,$(SUBDIRS_RUNNABLE)))

# same as above
TOO_SLOW := ./brainfuck.e ./ttt.e ./arith_simple.e ./matmult.e ./test_simplify_int.e
interpret: $(call F_INTERPSTAMPS,  $(filter-out $(TOO_SLOW),$(call F_SOURCES,$(SUBDIRS_RUNNABLE))))

# special targets. Up to Exercise 3, we can not yet correctly detect
# all errors, so we do not compile everything yet.
meilenstein1: $(call F_COMPSTAMPS, $(call F_SOURCES, $(SUBDIRS_EX1)))
meilenstein2: $(call F_COMPSTAMPS, $(call F_SOURCES, $(SUBDIRS_EX2)))
meilenstein3: $(call F_COMPSTAMPS, $(call F_SOURCES, $(SUBDIRS_EX3)))
meilenstein4: $(call F_INTERPFILES, $(call F_SOURCES, $(SUBDIRS_RUNNABLE))) interpret

clean:
	@echo removing stamp files
	@rm -f $(call F_COMPSTAMPS,   $(call F_SOURCES,$(ALLSUBDIRS)))
	@rm -f $(call F_INTERPSTAMPS, $(call F_SOURCES,$(ALLSUBDIRS)))
	@rm -f $(call F_INTERPFILES,  $(call F_SOURCES,$(ALLSUBDIRS)))
	@rm -f $(call F_RUNSTAMPS,    $(call F_SOURCES,$(ALLSUBDIRS)))
	@echo removing binaries and temp files
	@rm -f $(call F_BINS, $(call F_SOURCES, $(ALLSUBDIRS)))
	@rm -f $(call F_TEMPFILES, $(call F_SOURCES, $(ALLSUBDIRS)))
	@rm -f */*.tmp */*.o */*.S *.tmp *.o *.S 
	@rm -f */*.dot */*.dump */*.cil *.dot *.dump *.cil
	@rm -f */*.AST */*.CIL *.AST *.CIL

help:
	@echo Verfügbare Targets:
	@echo "   all          - default target, ruft 'compile' und 'run' auf"
	@echo "   compile      - kompiliert alle Programme (bis auf die, die Gleitkommazahlen verwenden)"
	@echo "   run          - testet die Programme, für die Testcases existieren"
	@echo "   clean        - räumt temporäre Dateien und Kompilatsergebnisse auf"
	@echo "   meilenstein1 - kompiliert alle Programme die nach M. 1 kompilieren sollen"
	@echo "   meilenstein2 - kompiliert alle Programme die nach M. 2 kompilieren sollen"
	@echo "   meilenstein3 - kompiliert alle Programme die nach M. 3 kompilieren sollen"
	@echo "   meilenstein4 - erzeugt IR aus allen lauffähigen Programmen und führt diese"
	@echo "                  in einem Interpreter aus."
	@echo "   help         - dieses Target"
	@echo "Zu Risiken und Nebenwirkungen lesen sie das README und fragen sie ihren "
	@echo "Übungsleiter oder Professor."


.PHONY: all clean compile run interpret meilenstein1 meilenstein2 meilenstein3 meilenstein4 meilenstein5
